= Lab 5: Implement AWS Secrets Manager with ROSA

== Learning objectives

By the end of this lab, you will be able to:

* Deploy and configure Secrets Store CSI Driver for Kubernetes
* Install AWS Secrets and Configuration Provider (ASCP) for ROSA integration
* Create and manage secrets in AWS Secrets Manager
* Configure IAM policies for least-privilege secret access
* Mount AWS Secrets Manager secrets as volumes in pods
* Understand CSI driver architecture and secret injection patterns

== Value proposition

*For field teams*: This lab demonstrates how ROSA enables separation of secrets from application code using AWS Secrets Manager, the secret management service customers already use. This is critical for compliance (PCI DSS 3.2.1, SOC 2) and reduces security risk from secrets in Git repositories or container images.

*Customer proof points*:

* *Compliance requirement*: Separating secrets from code satisfies PCI DSS 3.2.1, SOC 2, and HIPAA requirements for cryptographic key management
* *Developer security*: Eliminates hardcoded secrets in Git repositories, addressing the fact that secrets in code are a persistent security risk^1^
* *Operational efficiency*: Centralized secret rotation in AWS Secrets Manager updates all pods automatically without application redeployment
* *Audit capability*: AWS Secrets Manager audit logs track all secret access with pod-level attribution for compliance reporting

^1^ link:https://www.cncf.io/blog/2025/04/22/these-kubernetes-mistakes-will-make-you-an-easy-target-for-hackers/[CNCF: Kubernetes Security Best Practices^] - Secrets management remains a persistent security challenge

== Using AWS Secrets Manager CSI on Red Hat OpenShift Service on AWS with STS

The AWS Secrets and Configuration Provider (ASCP) provides a way to expose AWS Secrets as Kubernetes storage volumes. With the ASCP, you can store and manage your secrets in Secrets Manager and then retrieve them through your workloads running on Red Hat OpenShift Service on AWS.

== Deploying the AWS Secrets and Configuration Provider

. Use Helm to register the secrets store CSI driver.
+
[source,sh,role=execute]
----
helm repo add secrets-store-csi-driver \
    https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
----

. Update your Helm repositories.
+
[source,sh,role=execute]
----
helm repo update
----

. Install the secrets store CSI driver.
+
[source,sh,role=execute]
----
helm upgrade --install -n csi-secrets-store \
    csi-secrets-store-driver secrets-store-csi-driver/secrets-store-csi-driver
----

. Deploy the AWS provider.
+
[source,sh,role=execute]
----
oc -n csi-secrets-store apply -f \
    https://raw.githubusercontent.com/rh-mobb/documentation/main/content/misc/secrets-store-csi/aws-provider-installer.yaml
----

. Check that both Daemonsets are running.
+
[source,sh,role=execute]
----
oc -n csi-secrets-store get ds \
    csi-secrets-store-provider-aws \
    csi-secrets-store-driver-secrets-store-csi-driver
----

. Label the Secrets Store CSI Driver to allow use with the restricted pod security profile .
+
[source,sh,role=execute]
----
oc label csidriver.storage.k8s.io/secrets-store.csi.k8s.io security.openshift.io/csi-ephemeral-volume-profile=restricted
----

== Creating a Secret and IAM Access Policies

. Create a secret in Secrets Manager.
+
[source,sh,role=execute]
----
SECRET_ARN=$(aws --region "$REGION" secretsmanager create-secret \
    --name MySecret --secret-string \
    '{"username":"shadowman", "password":"hunter2"}' \
    --query ARN --output text); echo $SECRET_ARN
----

. Create an IAM Access Policy document.
+
[source,sh,role=execute]
----
cat << EOF > policy.json
{
   "Version": "2012-10-17",
   "Statement": [{
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue",
        "secretsmanager:DescribeSecret"
      ],
      "Resource": ["$SECRET_ARN"]
      }]
}
EOF
----

. Create an IAM Access Policy.
+
[source,sh,role=execute]
----
POLICY_ARN=$(aws --region "$REGION" --query Policy.Arn \
--output text iam create-policy \
--policy-name openshift-access-to-mysecret-policy \
--policy-document file://policy.json); echo $POLICY_ARN
----

. Create an IAM Role trust policy document .
+
[source,sh,role=execute]
----
cat <<EOF > trust-policy.json
{
   "Version": "2012-10-17",
   "Statement": [
   {
   "Effect": "Allow",
   "Condition": {
     "StringEquals" : {
       "${OIDC_ENDPOINT}:sub": ["system:serviceaccount:my-application:default"]
      }
    },
    "Principal": {
       "Federated": "arn:aws:iam::$AWS_ACCOUNT_ID:oidc-provider/${OIDC_ENDPOINT}"
    },
    "Action": "sts:AssumeRoleWithWebIdentity"
    }
    ]
}
EOF
----

. Create an IAM role
+
[source,sh,role=execute]
----
ROLE_ARN=$(aws iam create-role --role-name openshift-access-to-mysecret \
--assume-role-policy-document file://trust-policy.json \
--query Role.Arn --output text); echo $ROLE_ARN
----

. Attach the role to the policy 
+
[source,sh,role=execute]
----
aws iam attach-role-policy --role-name openshift-access-to-mysecret \
    --policy-arn $POLICY_ARN
----

== Create an Application to use this secret

. Create an OpenShift project  
+
[source,sh,role=execute]
----
oc new-project my-application
----

. Annotate the default service account to use the STS Role 
+
[source,sh,role=execute]
----
oc annotate -n my-application serviceaccount default \
    eks.amazonaws.com/role-arn=$ROLE_ARN
----

. Create a secret provider class to access our secret
+
[source,sh,role=execute]
----
cat << EOF | oc apply -f -
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-application-aws-secrets
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "MySecret"
        objectType: "secretsmanager"
EOF
----

. Create a deployment by using our secret 
+
[source,sh,role=execute]
----
cat << EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: my-application
  labels:
    app: my-application
spec:
  volumes:
  - name: secrets-store-inline
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "my-application-aws-secrets"
  containers:
  - name: my-application-deployment
    image: k8s.gcr.io/e2e-test-images/busybox:1.29
    command:
      - "/bin/sleep"
      - "10000"
    volumeMounts:
    - name: secrets-store-inline
      mountPath: "/mnt/secrets-store"
      readOnly: true
EOF
----

. Verify the pod has the secret mounted
+
[source,sh,role=execute]
----
oc exec -it my-application -- cat /mnt/secrets-store/MySecret
----
+
.Sample Output
[source,json,options=nowrap]
----
{"username":"shadowman", "password":"hunter2"}
----

== Summary

Congratulations! You have successfully implemented external secrets management using AWS Secrets Manager with ROSA.

=== What you accomplished

In this lab, you:

* ✅ Deployed Secrets Store CSI Driver for Kubernetes-native secret injection (demonstrating cloud-native architecture)
* ✅ Installed AWS Secrets and Configuration Provider (ASCP) for AWS integration (showing native AWS service support)
* ✅ Created secrets in AWS Secrets Manager with encrypted storage (proving security best practices)
* ✅ Configured IAM policies for least-privilege secret access (demonstrating zero trust principles)
* ✅ Mounted AWS secrets as volumes in pods using CSI driver (highlighting seamless Kubernetes integration)
* ✅ Verified secret injection without application code changes (proving developer experience excellence)

=== Key takeaways for customer conversations

* *Secrets externalization*: Application secrets stored in AWS Secrets Manager, never in Git repositories or container images
* *Automatic secret rotation*: AWS Secrets Manager rotates secrets; CSI driver automatically refreshes pod volumes without restarts
* *Least-privilege access*: IAM policies control which service accounts can access which secrets at granular level
* *Audit trail*: AWS CloudTrail logs all secret access attempts with pod-level attribution for compliance reporting
* *Zero code changes*: Applications read secrets from mounted volumes using standard file I/O, no SDK dependencies

=== Value demonstration for prospects

When showing this to customers, emphasize:

* *Compliance wins*: Satisfies PCI DSS 3.2.1 requirement to protect cryptographic keys with strong access control
* *Security risk reduction*: Eliminates hardcoded credentials in source code, preventing credential exposure in Git history
* *Operational efficiency*: Centralized secret management eliminates manual secret distribution to clusters
* *Developer productivity*: Developers focus on application logic, not secret management infrastructure

=== Real-world customer scenario

*Healthcare example*: A healthcare provider eliminated hardcoded database passwords across their microservices by implementing AWS Secrets Manager CSI. During their HIPAA audit, they demonstrated complete audit trails for all secret access and automated rotation policies, significantly streamlining the audit preparation process.

=== Architecture pattern explanation

The CSI driver pattern you implemented provides:

1. *Declarative secret references* → SecretProviderClass defines which AWS secrets to mount
2. *CSI driver intercepts pod creation* → When pod starts, CSI driver fetches secrets from AWS
3. *Secrets mounted as volumes* → Secrets appear as files in pod filesystem
4. *Automatic refresh* → CSI driver updates volume contents when AWS secrets rotate
5. *Pod-level isolation* → Each pod gets its own secret mount, no shared state

This architecture enables:

* *Separation of concerns* → Platform team manages CSI driver, application teams reference secrets
* *Least-privilege principle* → IAM policies restrict which service accounts access which secrets
* *Zero trust security* → No trust assumed, every secret access validated via AWS IAM

=== Technical deep dive points

For technical discussions, highlight:

* *CSI driver standard*: Uses Kubernetes Container Storage Interface, same pattern as EBS, EFS, and other storage plugins
* *Ephemeral volumes*: Secrets mounted as ephemeral volumes that exist only during pod lifetime, never persisted to disk
* *IRSA integration*: Combines with Lab 4's IRSA pattern for complete AWS service authentication
* *Secret caching*: CSI driver caches secrets to reduce AWS API calls while maintaining freshness

=== Defense-in-depth security complete

With this lab, you have now implemented all layers of defense-in-depth security:

* **Layer 1 (Environment)**: Validated AWS quota and ROSA prerequisites
* **Layer 2 (Access Control)**: Configured cluster authentication and authorization
* **Layer 3 (Observability)**: Centralized audit logging with CloudWatch
* **Layer 4 (Service Integration)**: Eliminated static credentials with IRSA
* **Layer 5 (Secrets Management)**: Externalized secrets with AWS Secrets Manager

This comprehensive security strategy provides enterprise-grade protection for containerized workloads.

=== Next steps

Congratulations on completing all 5 lab modules!

Proceed to the conclusion page to review your accomplishments and explore advanced security topics for production ROSA deployments.
















